## Creating a BookDetails SearchService

* [ Start with Spring data JPA](#Start-with-Spring-data-JPA)
* [To exercise: about validation part](#Start-here-for-the-Validation-part)
* [To exercise: about looking into an active Transaction(Optional)](#OPTIONAL-Look-into-an-active-Transaction)
* [To exercise: about the Rest part](#Start-here-for-the-Rest-part)

---

### What we want to build

<img src="img/01databasetests/whole-applicationstructure.png" alt="whole application structure" style="width:500px;height:500px" >

---

### Start with Spring data JPA

### We will focus on the database part first

<img src="img/01databasetests/focusondbpart.png" alt="focus on database part" style="width:500px;height:500px" >

---

### Create a maven project

In intellij create a new maven project.

Choose: File -> New -> Project ...

Select Maven and choose the appropriate Project SDK -> Click Next -> Finish

---

### Pick and choose from start.spring.io

Go to the [start.spring.io ](https://start.spring.io)website

We will not download a completely configured project. Instead we will pick and choose parts of the suggested pom file.

Check the different options in the page.

<img src="img/01databasetests/optionsinthepage.png" alt="options in the page" style="width:500px;height:500px" >

* Note: we choose Java 8 because it is still widely used.

* Use the ***Explore*** option to see the matching pom file.

<img src="img/01databasetests/explorepom.png" alt="explore pom" style="width:500px;height:150px" >


Copy the contents of the parent element into your own pom.xml

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.2.RELEASE</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
 ``` 

By default maven will assume java 6.
In springboot you can use the following property to set it to java 8

```xml
<properties>
  <java.version>1.8</java.version>
</properties>
```

Copy the properties element into your pom.xml

For the interested: lookup the java.version property in the spring-boot-starter-parent pom.

Add the following dependencies (copy them from the website to get up to date values )

<img src="img/01databasetests/adddependencies.png" alt="Add the following dependencies" style="width:500px;height:250px" >

your dependencies element in your pom should look similar to 

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>    
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

And add the build element

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

Create an entity Book
It has 3 fields
 - an id field of type Long (autogenerated) Note capital L
 - a name field of type String
 - a isbn13 field of type String

add necessary methods and constructors as you seem fit.

Create a BookEntityCrudTests class

- Annotate it with @DataJpaTest
- Autowire it with TestEntityManager

Use the TestEntityManager inside a test to persist flush an find a book entity.

Run the test => IT SHOULD FAIL!

The use of the @DataJpaTest annotation expects a configuration class. 

Add a SpringBootApplication annotation to the main entry point class.

```java
@SpringBootApplication
public class SpringApp {

    public static void main(String[] args) {
        SpringApplication.run(SpringApp.class,args);
    }
}
```

@SpringBootApplication is meta-annotated with @SpringBootConfiguration
This annotation can be found by @DataJpaTest to create the testApplicationContext.

To see data in the database annotate the test with the @Rollback(false) annotation. @DataJpaTest starts automatically a transaction but by default it will rollback it.

Create a BookRepository interface that extends from JpaRepository.
JpaRepository is Generic and expects the Entity Type and the type of the id field.

Create 2 finder methods on the BookRepository
 - a find by name method
 - a find by isbn13 method


***Create tests in the same test class to test if the methods behave as expected.***

Use the testEntityManager to insert test data

```java
Book defaultBook = BookBuilder.newBook().build();
testEntityManager.persistAndFlush(defaultBook);
testEntityManager.clear();
```

Why is it important to call clear() on the testEntityManager?

When you want to check several properties of the book that is returned in one test, you can use SoftAssertions:

```java
SoftAssertions.assertSoftly( softAssertions -> {
    softAssertions.assertThat(book.getId()).isNotNull();
    //More softAssertions!
});
```

Why are softAssertions used here, instead of the normal 'hard' assertions?

In our test code multiple book instances are created.
To keep a grip on the number of book instances with different state, potentially invalid state, we introduced a BookBuilder.
This class allows us to create once and for all and in one place, a valid instance.

```java
public class BookBuilder {

    public static final String DEFAULT_NAME = "IN_DE_BAN_VAN_DE_RING";
    public static final String DEFAULT_ISBN_13 ="978-0618640157" ;
    private String name;
    private String isbn13;

    public static BookBuilder newBook(){
        return new BookBuilder();
    }
    public BookBuilder() {
        name = DEFAULT_NAME;
        isbn13 = DEFAULT_ISBN_13;
    }
    public BookBuilder setName(String name){
        this.name = name;
        return this;
    }
    public BookBuilder setIsbn13(String isbn13){
        this.isbn13 = isbn13;
        return this;
    }
    public Book build(){
        return new Book(name, isbn13);
    }
}
```

Refactor your code and use the BookBuilder throughout your code.

Run the all the tests in the BookEntityCrudTests class a few times.
Do all the tests pass?
Why not?
Make the offending test insensitive for the order in which the tests are run.

The spring test reuses the spring context for different test because it is expensive to recreate the context for each individual test. One bean in the context is the EntityManagerFactory.
As opposed to the standalone tests we did earlier in the JPA training the tables and supporting object are not recreated for each test.

So the following assertions are tricky:

```java
//After one persist of a book whit a generated id in your test
//Less safe:
assertThat(book.getId()).isEqualTo(1L); //<== is this really the first generated value
//More safe:
assertThat(book.getId()).isNotNull();  //<== more safe, not dependent on the order

//After insert of one book in your test
int bookCount = bookRepository.findAll().size();
//Less safe:
assertThat(bookCount).isEqualTo(1); //<== less safe
// perhaps other tests inserted rows already

//More safe:
int bookCountBefore = bookRepository.findAll().size();

testEntityManager.persistFlush(newBook.build());
testEntityManager.clear();

int bookCountAfter = bookRepository.findAll().size();
assertThat(bookCountBefore + 1).isEqualTo(bookCountAfter);

```

The above assertions show that it can be quite tricky to write 'smart' tests.
Smart in the sense of `maintainable` tests.

### OPTIONAL Look into an active Transaction

---

Wouldn't be nice when we could look at the ongoing Transaction?
What is really going on in the database?
Are rows really inserted, updated or deleted in the database?

### Looking at uncommitted data

Add the the extra maven dependency with artifactId:
spring-boot-starter-web
This will add Tomcat where the h2-console webapp can run

Replace the @DataJpaTest annotation with @SpringBootTest annotation.
@SpringBootTest will scan all your spring beans in a typical spring boot application and will start Tomcat and the h2-console webapplication

Use:
```java
@SpringBootTest(
webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT,
properties = "server.port=8080")
```
to pick a specific port.

 or use:

```java
@SpringBootTest(
webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
```
to pick a random port so that port numbers do not collide when an other Tomcat instance is still running.
Look up the random port by searching for: Tomcat started in the generated log in the console

The specific functionality that @DataJpaTest provides we miss though.
We can't use both annotations because they have incompatible bootstrap policies.
We can use the meta annotations on @DataJpaTest independently though.

Add the following annotations to the test class:

```java
@Transactional
@AutoConfigureTestEntityManager
```

This gives us: 
* transactions for our tests
* a preconfigured TestEntityManager.

The @AutoConfigureTestDatabase annotation that is also part of the @DataJpaTest is left out.
That is a convenient choice because it would generate an H2 in memory database with a random name. (To make it more secure)
We opt for a h2 database with a fixed name (test) to more easily refer to this when we query database from the h2-console

Add a resources folder in the test folder

add a test properties file application.properties with the following content:

```bash
# Enabling H2 Console
spring.h2.console.enabled=true
# Custom H2 Console URL
spring.h2.console.path=/h2
spring.datasource.url=jdbc:h2:mem:test
spring.datasource.driverClassName=org.h2.Driver
```

When you run your test the url of the h2-console is by default: 

```http
http://localhost:8080/h2
```

What do you see?

Probably nothing because it is an in-memory database that is started when the tests start up to the point where the tests stop. We need to "break in" during the execution of a single test.


Use this code to look in the database if you like:

```java
@AfterEach
void keepH2OpenUntilUserDecidesOtherwise () {
        System.out.println("Enter RETURN to continue the test!");
        try {
            (new BufferedReader(new InputStreamReader(System.in))).readLine();
        } catch (IOException e) { //neglect exception }
}

/**
    * keepH2OpenUntilUserClosesIt() asks the user to enter RETURN to continue the test execution. The connection is kept open up to the last RETURN.
    * More importantly the H2 database is available for brosing it's content.
    * For this to work in <bold>IntelliJ</bold> the parameter -Deditable.java.test.console=true should be set in
    * Help -> Edit custom vm options
    * Restart IntelliJ
    * @throws IOException
    */
```

Enable the h2-console:

Run the following test:
```java
@Test
void persistAndFlushShouldFindNewBook() {

    int bookCountBefore = bookRepository.findAll().size();
    Book book = testEntityManager.persistFlushFind(newBook().build());
    testEntityManager.clear();
    int bookCountAfter = bookRepository.findAll().size();

    //Keep database alive and check if a row is present
    keepH2OpenUntilUserDecidesOtherwise();

    assertThat(bookCountBefore + 1).isEqualTo(bookCountAfter);
    assertThat(book.getName()).isEqualTo(bookName);
    assertThat(book.getIsbn()).isEqualTo(bookIsbn);
}
```

It should make the console available with the url: localhost:8080/h2
(user sa and empty password)

<img src="img/01databasetests/inloggenopinmemoryh2database.png" alt="inloggen op in memory h2 database" style="width:500px;height:500px" >

Do not forget to put Auto Commit off (The option in the middle of the top)

<img src="img/01databasetests/autocommitoff.png" alt="Do not forget to put Auto Commit off" style="width:250px;height:250px" >

Issue the SELECT * FROM BOOK query

<img src="img/01databasetests/websqlclient.png" alt="web sql client" style="width:500px;height:300px" >

The client shows 'no rows'. Why?

Issue the following sql query in the web sql client:

```sql
SELECT ID,
       USER_NAME,
       SESSION_START,
       ISOLATION_LEVEL,
       CONTAINS_UNCOMMITTED
FROM INFORMATION_SCHEMA.SESSIONS;
```

Look at the columns ISOLATION_LEVEL and CONTAINS_UNCOMMITTED.

One of the sessions contains UNCOMMITTED rows.
These rows are not shown to another session because the default isolation level is READ_COMMITTED. READ_COMMITTED says that a session only wants to see COMMITTED values.

For our purpose it is nice to see the uncommitted data because it allows us to check that work is really be done on the database.

Issue the following sql statements:

```sql
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

SELECT ID,
       USER_NAME,
       SESSION_START,
       ISOLATION_LEVEL,
       CONTAINS_UNCOMMITTED
FROM INFORMATION_SCHEMA.SESSIONS;
```

This should enable the current session to see the uncommitted data.

Issue again:

```sql
SELECT * FROM BOOK;
```

---

### Start here for the Validation part

---

## Introduction of Value class

We can use the Bean Validation API to make the String `more valid`

The isbn13 string should comply though to a complex validation rule

That is why we choose for the Value class

The isbn field in Book is at this moment a String

We want to impose restrictions on the values of the isbn field.

Change the field from:

```java

private String isbn13;

// into

private Isbn13 isbn13;

```

And create a new class

```java
public class Isbn13 {

    private String isbn;

    public Isbn13(String isbn) {
        this.isbn = isbn;
    }

    @Override
    public String toString() {
        return "Isbn13{" +
                "isbn='" + isbn + '\'' +
                '}';
    }

    public String getAsString() {
        return isbn;
    }
}
```

Change the tests in such a way that they can be compiled.
Run the tests?
What happens? why?

The Isbn13 is not a Basic type, i.e. jpa does not know how to persist it to the database.

Create an Isbn13AttributeConverter class that describes how the Isbn13 attribute can be converted to a String and visa versa.
The class should implement the AttributeConverter<T,R> interface.

Use the Converter or the Convert annotation to inform jpa of the converter.

## Validity checks for isbn 13

See [Checking the ISBN 13 check digit](https://en.wikipedia.org/wiki/International_Standard_Book_Number#ISBN-13_check_digit_calculation)


Implement the following tests by adding test for test the necessary checks in the constructor of the Isbn13 type.
Use the Assert.hasLength() and Assert.isTrue() methods from the import org.springframework.util.Assert; package.


```java
@Test
void whenAnInstanceIsCreatedWithAnEmptyStringItShouldThrowAnIllegalArgumentException() {

    assertThatThrownBy(() ->new Isbn13(""))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessage("Isbn is null or empty is not allowed!");

}

@Test
void whenAnInstanceIsCreatedWithANullStringItShouldThrowAnIllegalArgumentException() {

    String nullString=null;
    assertThatThrownBy(() ->new Isbn13(nullString))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("Isbn is null or empty is not allowed!");

}

@Test
void whenAnInstanceIsCreatedItWithOneDigitToMuchItShouldThrowAnIllegalArgumentException() {
    Book book = BookBuilder.newBook().build();
    String invalidIsbn13OfSize14 = book.getIsbn13().getAsString()+"1";
    assertThatThrownBy(() -> new Isbn13(invalidIsbn13OfSize14))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("A valid isbn13 code should contain exactly 13 digits, this isbn13 " + invalidIsbn13OfSize14 + " contains 14 digits");
}
@Test
void whenAnInstanceIsCreatedWithOneDigitShortOf13ItShouldThrowAnIllegalArgumentException() {
    Book book = BookBuilder.newBook().build();
    String invalidIsbn13OfSize12 = removeLeadingDigit(book.getIsbn13().getAsString());
    assertThatThrownBy(() -> new Isbn13(invalidIsbn13OfSize12))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("A valid isbn13 code should contain exactly 13 digits, this isbn13 " + invalidIsbn13OfSize12 + " contains 12 digits");
}

private String removeLeadingDigit(String isbn) {
    return isbn.substring(1);
}

@Test
void whenAnInstanceIsCreatedWith12DigitsAndOneNonNumericCharacterItShouldThrowAnIllegalArgumentException() {
    Book book = BookBuilder.newBook().build();
    String invalidIsbn13ContainingAnNonNumericCharacter ="A" + removeLeadingDigit(book.getIsbn13().getAsString());
    assertThatThrownBy(() -> new Isbn13(invalidIsbn13ContainingAnNonNumericCharacter))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("Invalid isbn13 it contains non numeric characters apart from the '-'(dash)");
}

@Test
void whenAnInstanceIsCreatedWithTheCheckDigitOneOffItShouldThrowAnIllegalArgumentException() {
    Book book = BookBuilder.newBook().build();
    String invalidIsbn13ContainingAnNonNumericCharacter = createNewIsbn13StringWithCheckDigitOneOff(book.getIsbn13().getAsString());
    assertThatThrownBy(() -> new Isbn13(invalidIsbn13ContainingAnNonNumericCharacter))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("The isbn13 has an invalid checkdigit");
}


private String createNewIsbn13StringWithCheckDigitOneOff(String isbn13) {
    long raisedCheckDigidByOne = raiseCheckDigidByOne(isbn13);
    return isbn13.substring(0, isbn13.length() -1 ) + raisedCheckDigidByOne;
}

private long raiseCheckDigidByOne(String isbn13) {
    return (Long.parseLong(isbn13.substring(isbn13.length() - 1)) + 1L) % 10L;
}

//To get more Confidence in the test we add an Parameterized test
@ParameterizedTest
@ValueSource(strings = {"978-1250301697","978-0615835600","978-1408883761","978-0345453747","978-0316016414","978-1541674066","978-0312265052"})
void whenAnInstanceIsCreatedWithTheCheckDigitOneOffItShouldThrowAnIllegalArgumentException(String validIsbn13Strings){
    String invalidIsbn13ContainingAnNonNumericCharacter = createNewIsbn13StringWithCheckDigitOneOff(validIsbn13Strings);
    assertThatThrownBy(() -> new Isbn13(invalidIsbn13ContainingAnNonNumericCharacter))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("The isbn13 has an invalid checkdigit");
}
```

To be done: discuss desirability of using spring Assert compared to e.g. the Guava preconditions

### Add a equals(Object other) and hashCode() method to the  Isbn13 class.

Use the IntelliJ Generate functionality ( Ctrl Return) -> Choose equals() and hashCode()

Follow the next steps:

* <img src="img/01databasetests/eqhashstep1.png" style="width:400px;height:250px" alt="dialogue step1">


* <img src="img/01databasetests/eqhashstep2.png" style="width:400px;height:250px" alt="dialogue step2">

* <img src="img/01databasetests/eqhashstep3.png" style="width:400px;height:250px" alt="dialogue step3">

* <img src="img/01databasetests/eqhashstep4.png" style="width:400px;height:250px" alt="dialogue step4">

Of course the equals() and hashCode() should be tested as well. That is no peanuts. These methods should comply to a several rules.

A special developed EqualsVerifier class can be used for this.
This will not be discussed here.
For the interested, See
[verify whether the contract for the equals and hashCode methods in a class is met](https://github.com/jqno/equalsverifier)

The above tests for the Isbn13 are all simple JUnit tests in the sense that the spring framework is not involved in testing.
That makes the tests fast, ideal for unit tests.

## What we want to build

* <img src="img/01databasetests/whole-applicationstructure.png" style="width:500px;height:500px" alt="whole application structure">

---

### Start here for the Rest part

---

### Focus on remote restservice

<img src="img/01databasetests/focusonrestpart.png" style="width:500px;height:500px" alt="focus on remote reservice part">


## Use isbn13 to call a remote webservice

### Use WireMock to mimic a real rest service  

* Compare WireMock with the in-memory H2 database
* There are several ways to `program` WireMock
* Here we will specify the behavior in the junit test
  * specify in the test the url to test and the wanted response

---

### Why you want to mock your Server in general

* reliable
* deterministic
* avoid rate limits and server costs
* cover edge case and error scenarios
* fast
* easy to manipulate

---

### Use spring cloud Wiremock

* Spring Cloud, is a spring framework build on Spring Boot
  * It offers solutions for all sort of challenges you meet in the cloud
  * It also offers a spring cloud maven dependency to mock [WireMock](http://wiremock.org)
  * WireMock is a product to reliable mock a restservice
    * it offers functionality to program the behavior of the restservice in the test

---

Add the following in your pom.xml

```xml
<!-- Add this property to the properties element -->
<spring-cloud-contract.version>2.2.4.RELEASE</spring-cloud-contract.version>

<!-- Add this dependency -->
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
<version>${spring-cloud-contract.version}</version>

<!-- Add this in the dependencyManagement element -->
<groupId>org.springframework.cloud</groupId>
<artifactId>spring-cloud-contract-dependencies</artifactId>
<version>${spring-cloud-contract.version}</version>
<type>pom</type>
<scope>import</scope>
```

* The dependency of type pom and scope import makes it easier to use other spring-cloud dependencies without introducing version conflicts.

* Program WireMock

```java
    @Test
    void programWireMock() {
        
        //Tell WireMock which Request to expect.
        //By default it looks at localhost and knows on which port it listens :-)
        String urlToStub = "/books/" + 123 + "/details";
        //Tell WireMock what to return, more details inside programWireMock
        String payloadToReturn = "<html><body>Hello Book!</body></html>";

        programWireMock(urlToStub, payloadToReturn);

        keepTestRunningUntilUserDecidesOtherwise();

    }

    private void programWireMock(String urlToStub, String payloadToReturn) {
        stubFor(get(urlEqualTo(urlToStub))
                .willReturn(aResponse()
                .withHeader("Content-Type", "text/html")
                .withBody(payloadToReturn)));
    }
```

* Note:
  * all the methods to program WireMock are static methods
  * the static imports are omitted

Open your favorite browser and enter the the url

```http
http://localhost:randomPort/books/123/details
```

To get the setUp running we need an extra piece of information => the port where WireMock is listening

```java
    @Value("${wiremock.server.port}")
    private int port;
```

The @Value annotation will search in the spring boot environment for a property `wiremock.server.port` and inject it in our test class

This property `wiremock.server.port` is set by the
`@AutoConfigureWireMock` annotation.
  * @AutoConfigureWireMock has a port attribute; port = 0 results in a random port
  * This port will be published in the environment as `wiremock.server.port`

Add the @SpringBootTest and @AutoConfigureWireMock(port = 0) on the class level.

```java
@SpringBootTest
@AutoConfigureWireMock(port = 0)
//configures random port for WireMock server
```

Print the port being used by WireMock to the console and issue a request from your browser:

http://localhost:randomPort/books/123/details


You should get a response int the browser from WireMock.

Make a typo in your url: What is the response of WireMock?

---

### An example request response from WireMock

* Logging in the console

```bash
 INFO 65388 --- [tp1881868027-23] WireMock                                 : Request received:
127.0.0.1 - GET /book/123/details

Accept: [text/plain, application/json, application/*+json, */*]
Connection: [keep-alive]
User-Agent: [Apache-HttpClient/4.5.12 (Java/1.8.0_252)]
Host: [localhost:11099]
Accept-Encoding: [gzip,deflate]

Matched response definition:
{
  "status" : 200,
  "body" : "<html><body>Hello Book!</body></html>",
  "headers" : {
    "Content-Type" : "text/html"
  }
}
Response:
HTTP/1.1 200
Content-Type: [text/html]
Matched-Stub-Id: [c51d34d2-b680-4ded-b3e6-51b859169488]
```


Investigate the WireMock methods in this example and familiarize yourself with the API
Write a few `tests`  where you experiment with different methods to program WireMock.


Call WireMock by issuing a call with a resttemplate from within your test method

To do this Autowire a RestTemplate in your test class


```java
@Autowired
private RestTemplate restTemplate;
```

Mimic in code the call you earlier made with the browser

```java
//The testUrl is the url you used in the browser
String body = new RestTemplate().getForEntity(testUrl, String.class).getBody();
//The payload is the content you told WireMock to return
assertThat(body).isEqualTo(payloadToReturn);
```

The restTemplate inside this test is the `working part` in a Service Component we still have to build.
Before we start with to that, first take a look at the output in the console.

Look at the output of the test.
If you run your test in the same app where we created the JPA experiments you will see that @SpringBootTest configures the complete application. You will see logging of JPA related configuration for instance. We `don't want that`, at this moment in this test we don't need the database.

Remove @SpringBootTest and add:

```java
@WebMvcTest() //configure spring WebMVC infrastructure and Controllers
@AutoConfigureWebClient(registerRestTemplate = true)
//Configures a restTemplate to be used in tests
```

When the tests are re-run they should run faster because no database setup is necessary anymore

In Spring Boot parlance: "we take a slice of our spring configuration"
Only the web related Spring Beans are configured.
`@WebMvcTest`

### Building the RemoteBookDetailsService

Refactor your code.
Place the call via the restTemplate in a separate method with the following signature:

```java
String getPayloadFromRestService(String testUrl)
```

We instantiate the RestTemplate inside this method, we do not consider this the job of this method.
For reasons to be discussed later we also want to make the testUrl variable in the port used.

Create the class RemoteBookDetailsService.
Add 2 fields to the class
* one of type RestTemplate named restTemplate
* one of type int named port
Make it a Service Component.
This insures that the springcontainer can autowire dependencies.
Add a constructor with one parameter of type RestTemplateBuilder
Inside the constructor use the builder to create a default RestTemplate that you assign to the restTemplate field.

Add the method 
```java
String getPayloadFromRestService(String testUrl)
```
to this class and implement it.
It should use the restTemplate to call the external rest service.

Check if the test still passes.

Your class should look something like so:

```java
public class RemoteBookDetailsService {

    private RestTemplate restTemplate;

    private int port;

    public RemoteStringService(RestTemplateBuilder builder) {
        this.restTemplate=builder.build();
    }

    public String getPayloadFromRestService(String testUrl) {
        return restTemplate.getForEntity(testUrl, String.class).getBody();
    }
}
```

Change the testUrl parameter of the getPayloadFromRestService in a local variable. 
Make the port field part of the testUrl value.
Create a package private setter for the port field to be able to change the port value inside our test.

### Reprogram our WireMock

We want to call the RemoteBookDetailsService for BookDetails.
Lets first declare the BookDetails class.

```java
public class BookDetails {
    private String bookname;
    private Isbn13 isbn13;
    private int numberOfCopiesSold;

    //add a constructor accepting values for the 3 fields

    //add a toString()
}
```

```java
private void programWireMockToReturnBookDetails(Isbn13 defaultIsbn13) {
    String json = "{" +
            "\"bookname\" : \"The lord of the rings\",\n" +
            "\"isbn13\" :\"" + defaultIsbn13.getAsString() + "\",\n" +
            "\"numberOfCopiesSold\" : \"1000000\"\n" +
            "}";

    stubFor(get(urlEqualTo("/book/" + defaultIsbn13.getAsString() + "/details"))
            .willReturn(aResponse().
            withHeader("Content-Type", "application/json")
            .withBody(json)));
}
```

Check with the browser if the WireMock is correctly programmed.

The json String inside programWireMockToReturnBookDetails should be marshaled to a Java BookDetails object

Change:

```java
     public String getPayloadFromRestService()
     //Into
    public BookDetails getPayloadFromRestService(Isbn13 isbn13)
```

Rename getPayloadFromRestService into getBookDetails and implement the method.

Use Assertj assertThat(bookDetails) is an instance of BookDetails and that the returned instance
has a field or property with the expected value.
Run the test

Your RemoteBookDetailsService could look like so:

```java
@Service
public class RemoteBookDetailsService {


    private RestTemplate restTemplate;
    private int port;

    public RemoteBookDetailsService(RestTemplateBuilder builder) {
        this.restTemplate = builder.build();
    }

    public BookDetails getBookDetails(Isbn13 isbn13) {

        String url = "http://localhost:" + this.port + "/book/" + isbn13.getAsString() + "/details";

            BookDetails bookDetails = this.restTemplate
                    .getForObject(url, BookDetails.class);
            return bookDetails;
    }

    void setPort(int port) {
        this.port=port;
    }
}
```

Your test could look like this:

```java
@Test
public void getBookDetailsShouldReturnDefaultBookDetalsWhenCalledWithDefaultIsbn13() {
    Isbn13 defaultIsbn13 = BookBuilder.newBook().build().getIsbn13();

    programWireMockToReturnBookDetails(defaultIsbn13);
    this.service.setPort(port);
    BookDetails bookDetails = this.service.getBookDetails(defaultIsbn13);
    assertThat(bookDetails)
            .isInstanceOf(BookDetails.class)
            .hasFieldOrPropertyWithValue("isbn13", defaultIsbn13);
}
```

Implement error scenarios with WireMock
Program WireMock to return NOT_FOUND
This time we use the defaultIsbn value to generate a NOT_FOUND http status.
Use the withStatus(int) method on aResponse()
Use the HttpStatus class to find the correct int value for NOT_FOUND

Create a test where you program WireMock to return NOT_FOUND and call getBookDetails.

Look at the stackTrace.
The exception thrown is the HttpClientErrorException.
A sub class of HttpClientErrorException is the HttpStatusCodeException.
Catch the exception.
If the exception has a statusCode equal to HttpStatus.NOT_FOUND then throw the BookDetailsIsbn13NotFoundException.
If it is an other exception just throw it again.

```java
String message= "BookDetails with international standard book identification number " + isbn13.getAsString() + " not found"
throw new BookDetailsIsbn13NotFoundException(message, ex);
```

Your WireMock stub could look like:

```java
private void programWireMockToReturnStatusNotFound(Isbn13 defaultIsbn13) {
    stubFor(get(urlEqualTo("/books/" + defaultIsbn13.getAsString() + "/details"))
            .willReturn(aResponse().withStatus(HttpStatus.NOT_FOUND)));
}
```

Your code of the 

```java
public BookDetails getBookDetails(Isbn13 isbn13) {

    String url = "http://localhost:" + this.port + "/book/" + isbn13.getAsString() + "/details";
    try {
        BookDetails bookDetails = this.restTemplate
                .getForObject(url, BookDetails.class);
        return bookDetails;
        //HttpStatusCodeException is a sub class of RestClientException, see the diagrams of both classes
    } catch (
            HttpStatusCodeException ex) {
        if (HttpStatus.NOT_FOUND.equals(ex.getStatusCode())) {
            throw new BookDetailsIsbn13NotFoundException(
                "BookDetails with international standard book identification number " + isbn13.getAsString() + " not found", ex);
        }
        throw ex;
    }
}
```
        

